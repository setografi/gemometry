Player.jsx
import React, { useEffect } from "react";

function Player({ canvasRef, snake, food, powerUp, gridSize, isEating }) {
  const drawSnakeSegment = (ctx, segment, index, total, isEating) => {
    const headColor = { r: 77, g: 77, b: 255 }; // Warna asli untuk kepala
    const tailColor = { r: 92, g: 92, b: 182 }; // Warna lebih gelap untuk ekor

    const gradientFactor = index / total;
    const segmentColor =
      total === 0
        ? headColor // Set Warna Default saat hanya 1 kotak
        : {
            r: Math.floor(
              headColor.r + (tailColor.r - headColor.r) * gradientFactor
            ),
            g: Math.floor(
              headColor.g + (tailColor.g - headColor.g) * gradientFactor
            ),
            b: Math.floor(
              headColor.b + (tailColor.b - headColor.b) * gradientFactor
            ),
          };

    // Efek neon
    ctx.shadowColor = `rgb(${segmentColor.r}, ${segmentColor.g}, ${segmentColor.b})`;
    ctx.shadowBlur = 15;
    ctx.fillStyle = `rgb(${segmentColor.r}, ${segmentColor.g}, ${segmentColor.b})`;

    let width = gridSize - 2;
    let height = gridSize - 2;
    let posX = segment.x;
    let posY = segment.y;

    // Efek scaling saat makan (hanya untuk kepala)
    if (index === 0 && isEating) {
      const scaleFactorX = 1.3;
      const scaleFactorY = 1.3;
      width *= scaleFactorX;
      height *= scaleFactorY;
      // Menyesuaikan posisi agar scaling tetap dari tengah
      posX -= (width - (gridSize - 2)) / 2;
      posY -= (height - (gridSize - 2)) / 2;
    }

    // Draw rounded rectangle for each segment
    const radius = 10;
    ctx.beginPath();
    ctx.moveTo(posX + radius, posY);
    ctx.lineTo(posX + width - radius, posY);
    ctx.quadraticCurveTo(posX + width, posY, posX + width, posY + radius);
    ctx.lineTo(posX + width, posY + height - radius);
    ctx.quadraticCurveTo(
      posX + width,
      posY + height,
      posX + width - radius,
      posY + height
    );
    ctx.lineTo(posX + radius, posY + height);
    ctx.quadraticCurveTo(posX, posY + height, posX, posY + height - radius);
    ctx.lineTo(posX, posY + radius);
    ctx.quadraticCurveTo(posX, posY, posX + radius, posY);
    ctx.closePath();
    ctx.fill();

    // Reset shadow untuk performa
    ctx.shadowBlur = 0;

    // Add details to head segment
    if (index === 0) {
      // Eyes with neon effect
      ctx.shadowColor = "#FFFFFF";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(posX + width / 4, posY + height / 3, 3, 0, Math.PI * 2);
      ctx.arc(posX + (width * 3) / 4, posY + height / 3, 3, 0, Math.PI * 2);
      ctx.fill();

      // Black pupils
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(posX + width / 4, posY + height / 3, 1.5, 0, Math.PI * 2);
      ctx.arc(posX + (width * 3) / 4, posY + height / 3, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  };

  useEffect(() => {
    if (!canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    // Clear previous frame
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw snake with neon effect
    snake.forEach((segment, index) => {
      drawSnakeSegment(ctx, segment, index, snake.length - 1, isEating);
    });

    // Draw food with neon effect
    if (food) {
      ctx.shadowColor = food.color;
      ctx.shadowBlur = 20;
      ctx.fillStyle = food.color;

      const centerX = food.x + gridSize / 2 - 1;
      const centerY = food.y + gridSize / 2 - 1;
      const radius = (gridSize - 4) / 2;

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();

      // Reset shadow effect
      ctx.shadowBlur = 0;
    }

    // Draw power-up
    if (powerUp) {
      ctx.shadowColor = powerUp.color;
      ctx.shadowBlur = 25;
      ctx.fillStyle = powerUp.color;

      const centerX = powerUp.x + gridSize / 2;
      const centerY = powerUp.y + gridSize / 2;
      const size = gridSize - 6;

      // Draw star shape for power-up
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
        const x = centerX + (Math.cos(angle) * size) / 2;
        const y = centerY + (Math.sin(angle) * size) / 2;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    ctx.shadowBlur = 0;
  }, [canvasRef, snake, food, powerUp, gridSize, isEating]);

  return null;
}

export default Player;





GamePage.jsx
import React, { useEffect, useState, useRef, useCallback } from "react";

import { ScoringSystem } from "../utils/systems/ScoringSystem";
import { FoodSystem } from "../utils/systems/FoodSystem";
import { PowerUpSystem } from "../utils/systems/PowerUpSystem";
import { useGameStore } from "../utils/store/gameStore";

import Player from "../components/sprites/Player";

import Map from "../components/tilesets/Map";
import VirtualPad from "../components/ui/VirtualPad";
import Popup from "../components/ui/Popup";

function GamePage() {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const scoringSystem = useRef(new ScoringSystem());
  const foodSystem = useRef(new FoodSystem(20));
  const powerUpSystem = useRef(new PowerUpSystem(20));

  const gridSize = 20;
  const {
    score,
    highScore,
    updateScore,
    gameState,
    updateHighScore,
    updateGameState,
  } = useGameStore();
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [isEating, setIsEating] = useState(false);
  const [showPopup, setShowPopup] = useState(false);

  // Initialize game dimensions and starting positions
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const width =
          Math.floor(containerRef.current.clientWidth / gridSize) * gridSize;
        const height =
          Math.floor(containerRef.current.clientHeight / gridSize) * gridSize;
        setDimensions({ width, height });

        // Initialize snake and food positions only if not already set
        if (gameState.snake[0].x === 0 && gameState.snake[0].y === 0) {
          const initialX = Math.floor(width / (2 * gridSize)) * gridSize;
          const initialY = Math.floor(height / (2 * gridSize)) * gridSize;
          const initialSnake = [{ x: initialX, y: initialY }];

          // Generate initial food
          const initialFood = foodSystem.current.generateFood(
            width,
            height,
            initialSnake
          );

          updateGameState({
            snake: initialSnake,
            food: initialFood,
          });
        }
      }
    };

    updateDimensions();
    window.addEventListener("resize", updateDimensions);
    return () => window.removeEventListener("resize", updateDimensions);
  }, []);

  // Handle keyboard controls
  const handleKeyPress = useCallback(
    (e) => {
      if (gameState.isGameOver) return;

      const directions = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
      };

      if (directions[e.key]) {
        updateGameState((prev) => {
          if (
            prev.direction.x === -directions[e.key].x &&
            prev.direction.y === -directions[e.key].y
          ) {
            return prev;
          }
          return { ...prev, direction: directions[e.key] };
        });
      }
    },
    [gameState.isGameOver, updateGameState]
  );

  useEffect(() => {
    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [handleKeyPress]);

  //Handle virtual controls for mobile + tablet
  const handleVirtualPadInput = (newDirection) => {
    updateGameState((prev) => {
      if (
        prev.direction.x === -newDirection.x &&
        prev.direction.y === -newDirection.y
      ) {
        return prev;
      }
      return { ...prev, direction: newDirection };
    });
  };

  const { isGhostMode } = useGameStore().gameState;

  // useEffect(() => {
  //   if (isGhostMode) {
  //     console.log("Ghost mode aktif!");
  //   }
  // }, [isGhostMode]);

  // Collisions
  const checkCollision = (head, snakeBody) => {
    if (gameState.isGhostMode) {
      return false;
    }

    return snakeBody.some((segment, index) => {
      if (index === 0) return false;
      return segment.x === head.x && segment.y === head.y;
    });
  };

  // Main game loop
  useEffect(() => {
    if (!canvasRef.current || dimensions.width === 0 || gameState.isGameOver)
      return;

    const gameLoop = setInterval(() => {
      updateGameState((prev) => {
        if (prev.isGameOver) {
          clearInterval(gameLoop);
          return prev;
        }

        const newHead = {
          x:
            (prev.snake[0].x + prev.direction.x * gridSize + dimensions.width) %
            dimensions.width,
          y:
            (prev.snake[0].y +
              prev.direction.y * gridSize +
              dimensions.height) %
            dimensions.height,
        };

        // Check for collisions
        if (!prev.isGhostMode && checkCollision(newHead, prev.snake)) {
          return { ...prev, isGameOver: true };
        }

        // Check if snake ate food
        const ateFood =
          prev.food && newHead.x === prev.food.x && newHead.y === prev.food.y;

        if (ateFood) {
          setIsEating(true);
          setTimeout(() => setIsEating(false), 200);

          const points = prev.food.points * prev.scoreMultiplier;
          const newScore = scoringSystem.current.addScore(points);
          updateScore(newScore);
          updateHighScore(scoringSystem.current.getHighScore());

          if (newScore === 20) {
            setShowPopup(true);
          }

          // Generate new food
          const newSnake = [newHead, ...prev.snake];
          const newFood = foodSystem.current.generateFood(
            dimensions.width,
            dimensions.height,
            newSnake
          );

          const newPowerUp = powerUpSystem.current.generatePowerUp(
            dimensions.width,
            dimensions.height,
            newSnake
          );

          // Snake grows by one segment
          return {
            ...prev,
            snake: newSnake,
            food: newFood,
            powerUp: newPowerUp || prev.powerUp,
          };
        }

        // Check for power-up collison
        const hitPowerUp =
          prev.powerUp &&
          newHead.x === prev.powerUp.x &&
          newHead.y === prev.powerUp.y;

        if (hitPowerUp) {
          const newGameState = powerUpSystem.current.activatePowerUp(
            prev.powerUp.type,
            prev
          );

          powerUpSystem.current.startPowerUpTimer(
            prev.powerUp.duration,
            updateGameState
          );

          const newPowerUp = powerUpSystem.current.generatePowerUp(
            dimensions.width,
            dimensions.height,
            [newHead, ...prev.snake]
          );
          return { ...newGameState, powerUp: newPowerUp };
        }

        // Normal movement without growth
        const newSnake = [newHead, ...prev.snake.slice(0, -1)];

        return {
          ...prev,
          snake: newSnake,
        };
      });
    }, gameState.updateInterval);

    return () => clearInterval(gameLoop);
  }, [dimensions, gameState.isGameOver, gameState.updateInterval]);

  // Handle game over
  const handleRestart = () => {
    const initialX = Math.floor(dimensions.width / (2 * gridSize)) * gridSize;
    const initialY = Math.floor(dimensions.height / (2 * gridSize)) * gridSize;
    const initialSnake = [{ x: initialX, y: initialY }];
    const initialFood = foodSystem.current.generateFood(
      dimensions.width,
      dimensions.height,
      initialSnake
    );

    scoringSystem.current.resetScore();
    updateScore(0);

    updateGameState({
      snake: initialSnake,
      food: initialFood,
      direction: { x: 1, y: 0 },
      isGameOver: false,
    });
  };

  return (
    <section
      ref={containerRef}
      className="fixed inset-0 w-full h-full overflow-hidden"
    >
      <div className="absolute top-4 left-4 flex flex-row space-x-6 z-10">
        <h2 className="text-base md:text-lg text-white font-bold">
          Score: {score}
        </h2>
        <h2 className="text-base md:text-lg text-white">
          High Score: {highScore}
        </h2>
        {powerUpSystem.current.isActive() && (
          <h2 className="text-base md:text-lg text-yellow-400">
            Power-up: {powerUpSystem.current.getActivePowerUp()}
          </h2>
        )}
      </div>

      {gameState.isGameOver && (
        <div className="absolute inset-0 bg-[#121212] bg-opacity-50 flex items-center justify-center z-20">
          <div className="bg-white p-8 rounded-lg text-center">
            <h2 className="text-2xl font-bold mb-4">Game Over!</h2>
            <p className="text-lg mb-4">Final Score: {score}</p>
            <button
              className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
              onClick={handleRestart}
            >
              Play Again
            </button>
          </div>
        </div>
      )}

      {showPopup && <Popup onClose={() => setShowPopup(false)} />}

      <Map canvasRef={canvasRef} dimensions={dimensions} gridSize={gridSize} />
      <Player
        canvasRef={canvasRef}
        snake={gameState.snake}
        food={gameState.food}
        powerUp={gameState.powerUp}
        gridSize={gridSize}
        isEating={isEating}
      />

      <VirtualPad onDirectionChange={handleVirtualPadInput} />
    </section>
  );
}

export default GamePage;
